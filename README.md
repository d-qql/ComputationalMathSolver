# ComputationalMathSolver
# Решалка твоей контрольной по вычматам
## 1. Численное дифференцирование методом неопределенных коэффициентов
Найти первую производную функции, заданной шаблоном в точке x = 3
|x|1|2|3|
|-|-|-|-|
|y|0.5|0.25|0.25|
### main.cpp:
```cpp
#include "Derivation/UnderfinedCoefficientsMethod.hpp"

int main() {
    // создаем шаблон
    Template our_template = {
                      {1,   2,    3},
                      {0.5, 0.25, 0.25}
                      };
    // создаем экземпляр класса метода неопределенных коэффициентов, послав шаблон аргументом.
    UnderfinedCoefficientsMethod UCM(our_template);
    // вычисляем значение производной с помощью метода calculate, послав аргументом порядковый номер 
    // точки шаблона(начиная с нуля), в которой необходимо найти производную
    std::cout << UCM.calculate(2);
    return 0;
}
```
Если необходимо найти производную более высокого порядка (к примеру 3-ю), необходимо послать 
порядок производной вторым аргументом:
```cpp
UCM.calculate(2, 3);
```
## 2. Интерполяция
Интерполировать значение функции, заданной шаблоном в точке x = 2.5

|x|1|2|3|4|
|-|-|-|-|-|
|y|1|4|9|16|

### main.cpp:
```cpp
#include "Interpolation/Newton.hpp"

int main() {
    // создаем шаблон
    Template t = {
                  {1, 2, 3, 4},
                  {1, 4, 9, 16}
                  };
    // создаем экземпляр интерполятора Ньютона
    Newton newton(t);
    // вызываем метод интерполяции в нужной точке
    std::cout << newton.interpolate(2.5) <<std::endl;
    return 0;
}
```
Аналогично можно использовать метод Лагранжа, вместо Ньютона(идентичны):
### main.cpp:
```cpp
#include "Interpolation/Lagrange.hpp"

int main() {
    // создаем шаблон
    Template t = {
                  {1, 2, 3, 4},
                  {1, 4, 9, 16}
                  };
    // создаем экземпляр интерполятора Лагранжа
    Lagrange lagrange(t);
    // вызываем метод интерполяции в нужной точке
    std::cout << lagrange.interpolate(2.5) <<std::endl;
    return 0;
}
```
## 3. Интегрирование
